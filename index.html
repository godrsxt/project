<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hero Quest: 30 Levels</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #202020;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* Prevent browser zooming */
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(to bottom, #87CEEB, #E0F6FF);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Elements */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let touches pass through to buttons */
        }

        .hud {
            position: absolute;
            top: 10px;
            left: 20px;
            font-size: 20px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
        }

        .level-indicator {
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 20px;
            font-weight: bold;
            color: gold;
            text-shadow: 2px 2px 0 #000;
        }

        /* Controls */
        .controls-area {
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 120px;
            pointer-events: auto;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .d-pad {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .action-pad {
            display: flex;
            gap: 15px;
            align-items: flex-end;
        }

        .btn {
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            user-select: none;
            backdrop-filter: blur(5px);
            transition: background 0.1s;
        }

        .btn:active {
            background: rgba(255, 255, 255, 0.6);
            transform: scale(0.95);
        }

        .btn-rect {
            border-radius: 10px;
            width: 80px;
        }

        .attack-btn {
            background: rgba(255, 50, 50, 0.4);
            border-color: #ffaaaa;
        }

        #message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
            display: none; /* Hidden by default */
        }

        h1 { margin: 0 0 20px 0; font-size: 40px; text-transform: uppercase; color: gold; }
        p { font-size: 18px; margin-bottom: 30px; }
        button.start-btn {
            padding: 15px 40px;
            font-size: 24px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud">HP: <span id="hp-display">3</span> | Score: <span id="score-display">0</span></div>
        <div class="level-indicator">Level: <span id="level-display">1</span>/30</div>
        
        <div class="controls-area">
            <div class="d-pad">
                <div class="btn btn-rect" id="btn-left">←</div>
                <div class="btn btn-rect" id="btn-right">→</div>
            </div>
            <div class="action-pad">
                <div class="btn attack-btn" id="btn-attack">⚔️</div>
                <div class="btn" id="btn-jump">↑</div>
            </div>
        </div>
    </div>

    <div id="message-overlay">
        <h1 id="msg-title">Hero Quest</h1>
        <p id="msg-sub">Reach the Green Flag!</p>
        <button class="start-btn" onclick="startGame()">PLAY</button>
    </div>
</div>

<script>
    /* --- GAME ENGINE & CONSTANTS --- */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Game State
    let gameState = {
        level: 1,
        maxLevels: 30,
        score: 0,
        isRunning: false,
        cameraX: 0
    };

    // Load Save
    if(localStorage.getItem('heroQuestLevel')) {
        gameState.level = parseInt(localStorage.getItem('heroQuestLevel'));
        gameState.score = parseInt(localStorage.getItem('heroQuestScore') || 0);
    }

    // Physics
    const GRAVITY = 0.6;
    const FRICTION = 0.8;
    const SPEED = 5;
    const JUMP_FORCE = -14;

    // Entities
    let player = {
        x: 50, y: 100, w: 40, h: 40,
        vx: 0, vy: 0,
        hp: 3, maxHp: 3,
        grounded: false,
        attacking: false,
        attackTimer: 0,
        facingRight: true,
        invulnerable: 0,
        color: '#ff4444' // Mario Red
    };

    let platforms = [];
    let enemies = [];
    let particles = [];
    let goal = { x: 0, y: 0, w: 50, h: 100 };

    // Input
    let keys = { left: false, right: false, jump: false, attack: false };

    /* --- RESIZING --- */
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    /* --- LEVEL GENERATION (The Procedural Logic) --- */
    function generateLevel(levelNum) {
        platforms = [];
        enemies = [];
        particles = [];
        player.x = 50;
        player.y = 100;
        player.vx = 0;
        player.vy = 0;
        player.hp = player.maxHp;
        gameState.cameraX = 0;

        // Difficulty scalers
        const levelLength = 2000 + (levelNum * 300); // Levels get longer
        const gapFrequency = Math.min(0.6, 0.1 + (levelNum * 0.02)); // More gaps
        const enemyDensity = Math.min(0.8, 0.1 + (levelNum * 0.03)); // More enemies

        // 1. Ground Generation
        let currentX = 0;
        const groundY = canvas.height - 60;
        
        // Starting platform (safe zone)
        platforms.push({ x: -100, y: groundY, w: 400, h: 200, type: 'ground' });
        currentX = 300;

        while (currentX < levelLength) {
            // Determine gap
            let isGap = Math.random() < gapFrequency;
            let gapSize = isGap ? 100 + (Math.random() * (100 + (levelNum * 2))) : 0; // Gaps get wider
            
            if (isGap) currentX += gapSize;

            // Platform width
            let platW = 150 + Math.random() * 300;
            // Platform height (variation)
            let platY = groundY - (Math.random() > 0.7 ? (Math.random() * 150) : 0);

            platforms.push({ x: currentX, y: platY, w: platW, h: 400, type: 'ground' });

            // 2. Enemy Spawning
            if (Math.random() < enemyDensity && currentX > 400) {
                enemies.push({
                    x: currentX + 50,
                    y: platY - 40,
                    w: 40, h: 40,
                    vx: 2 + (levelNum * 0.1), // Enemies get faster
                    startX: currentX,
                    endX: currentX + platW,
                    type: Math.random() > 0.8 && levelNum > 5 ? 'spiky' : 'walker'
                });
            }

            currentX += platW;
        }

        // 3. The Goal
        goal.x = currentX + 50;
        goal.y = groundY - 60;
        platforms.push({ x: currentX, y: groundY, w: 200, h: 200, type: 'ground' });

        updateUI();
    }

    /* --- GAME LOOP --- */
    function update() {
        if (!gameState.isRunning) return;

        // 1. Player Movement
        if (keys.left) { player.vx -= 1; player.facingRight = false; }
        if (keys.right) { player.vx += 1; player.facingRight = true; }
        
        player.vx *= FRICTION;
        player.vy += GRAVITY;

        player.x += player.vx;
        player.y += player.vy;

        // 2. Collision detection (Platforms)
        player.grounded = false;
        platforms.forEach(plat => {
            if (checkCollision(player, plat)) {
                // Determine side of collision
                let dx = (player.x + player.w/2) - (plat.x + plat.w/2);
                let dy = (player.y + player.h/2) - (plat.y + plat.h/2);
                let width = (player.w + plat.w) / 2;
                let height = (player.h + plat.h) / 2;
                let crossWidth = width * dy;
                let crossHeight = height * dx;

                if (Math.abs(dx) <= width && Math.abs(dy) <= height) {
                    if (crossWidth > crossHeight) {
                        if (crossWidth > -crossHeight) { // Bottom
                            player.y = plat.y + plat.h;
                            player.vy = 0;
                        } else { // Left
                            player.x = plat.x - player.w;
                            player.vx = 0;
                        }
                    } else {
                        if (crossWidth > -crossHeight) { // Right
                            player.x = plat.x + plat.w;
                            player.vx = 0;
                        } else { // Top
                            player.y = plat.y - player.h;
                            player.vy = 0;
                            player.grounded = true;
                        }
                    }
                }
            }
        });

        // 3. Jump
        if (keys.jump && player.grounded) {
            player.vy = JUMP_FORCE;
            player.grounded = false;
        }

        // 4. Attack Logic
        if (player.attacking) {
            player.attackTimer--;
            if (player.attackTimer <= 0) player.attacking = false;
            
            // Attack hitbox check against enemies
            let attackBox = {
                x: player.facingRight ? player.x + player.w : player.x - 40,
                y: player.y,
                w: 40,
                h: 40
            };
            
            enemies.forEach((enemy, index) => {
                if (checkCollision(attackBox, enemy)) {
                    createParticles(enemy.x, enemy.y, 'orange');
                    enemies.splice(index, 1);
                    gameState.score += 100;
                    updateUI();
                }
            });
        }

        // 5. Enemy Logic
        enemies.forEach(enemy => {
            enemy.x += enemy.vx;
            // Patrol logic
            if (enemy.x > enemy.endX - enemy.w || enemy.x < enemy.startX) {
                enemy.vx *= -1;
            }

            // Player vs Enemy
            if (player.invulnerable <= 0 && checkCollision(player, enemy)) {
                // Mario style: Jump on head
                if (player.vy > 0 && player.y + player.h < enemy.y + (enemy.h/2)) {
                    player.vy = -8; // Bounce
                    enemies = enemies.filter(e => e !== enemy);
                    createParticles(enemy.x, enemy.y, 'orange');
                    gameState.score += 100;
                } else {
                    takeDamage();
                }
                updateUI();
            }
        });

        if (player.invulnerable > 0) player.invulnerable--;

        // 6. Camera Follow
        let targetCamX = player.x - canvas.width / 3;
        // Smooth camera
        gameState.cameraX += (targetCamX - gameState.cameraX) * 0.1;
        if(gameState.cameraX < 0) gameState.cameraX = 0;

        // 7. Win/Lose Conditions
        // Check Goal
        if (checkCollision(player, goal)) {
            nextLevel();
        }
        // Fall off map
        if (player.y > canvas.height + 100) {
            resetLevel();
        }

        // Particles
        particles.forEach((p, i) => {
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            if(p.life <= 0) particles.splice(i, 1);
        });
    }

    function draw() {
        // Clear background
        ctx.fillStyle = '#87CEEB'; 
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.translate(-Math.floor(gameState.cameraX), 0);

        // Draw Goal
        ctx.fillStyle = '#4CAF50'; // Pole
        ctx.fillRect(goal.x + 10, goal.y - 100, 10, 200);
        ctx.fillStyle = '#FFD700'; // Flag
        ctx.beginPath();
        ctx.moveTo(goal.x + 20, goal.y - 100);
        ctx.lineTo(goal.x + 70, goal.y - 80);
        ctx.lineTo(goal.x + 20, goal.y - 60);
        ctx.fill();

        // Draw Platforms
        ctx.fillStyle = '#5D4037'; // Dirt
        platforms.forEach(p => {
            ctx.fillRect(p.x, p.y, p.w, p.h);
            // Grass top
            ctx.fillStyle = '#388E3C'; 
            ctx.fillRect(p.x, p.y, p.w, 20);
            ctx.fillStyle = '#5D4037';
        });

        // Draw Enemies
        enemies.forEach(e => {
            ctx.fillStyle = e.type === 'spiky' ? '#555' : '#8B0000';
            ctx.fillRect(e.x, e.y, e.w, e.h);
            // Eyes
            ctx.fillStyle = 'white';
            ctx.fillRect(e.x + 5, e.y + 10, 10, 10);
            ctx.fillRect(e.x + 25, e.y + 10, 10, 10);
        });

        // Draw Player
        ctx.globalAlpha = player.invulnerable > 0 && Math.floor(Date.now() / 100) % 2 === 0 ? 0.5 : 1;
        ctx.fillStyle = player.color;
        ctx.fillRect(player.x, player.y, player.w, player.h);
        
        // Attack Swing visual
        if (player.attacking) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            let swingX = player.facingRight ? player.x + player.w : player.x - 40;
            ctx.fillRect(swingX, player.y + 10, 40, 20);
        }

        // Particles
        ctx.globalAlpha = 1;
        particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, p.s, p.s);
        });

        ctx.restore();

        requestAnimationFrame(update);
        draw(); // Loop draw separately to keep running
    }

    /* --- HELPERS --- */
    function checkCollision(r1, r2) {
        return (r1.x < r2.x + r2.w &&
                r1.x + r1.w > r2.x &&
                r1.y < r2.y + r2.h &&
                r1.y + r1.h > r2.y);
    }

    function createParticles(x, y, color) {
        for(let i=0; i<10; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 20,
                color: color,
                s: Math.random() * 5 + 2
            });
        }
    }

    function takeDamage() {
        if (player.invulnerable > 0) return;
        player.hp--;
        player.invulnerable = 60; // Frames of invincibility
        createParticles(player.x, player.y, 'red');
        if (player.hp <= 0) {
            resetLevel();
        }
    }

    function nextLevel() {
        gameState.level++;
        if(gameState.level > gameState.maxLevels) {
            alert("YOU WIN THE GAME!");
            gameState.level = 1;
            gameState.score = 0;
        }
        // Save Progress
        localStorage.setItem('heroQuestLevel', gameState.level);
        localStorage.setItem('heroQuestScore', gameState.score);
        
        showMsg(`Level ${gameState.level}`, "Get Ready!");
    }

    function resetLevel() {
        player.hp = player.maxHp;
        player.x = 50;
        player.y = 100;
        player.vx = 0;
        player.vy = 0;
        gameState.score = Math.max(0, gameState.score - 50); // Penalty
        updateUI();
        showMsg("Ouch!", "Try Again");
    }

    function showMsg(title, sub) {
        gameState.isRunning = false;
        document.getElementById('msg-title').innerText = title;
        document.getElementById('msg-sub').innerText = sub;
        document.getElementById('message-overlay').style.display = 'flex';
    }

    function startGame() {
        document.getElementById('message-overlay').style.display = 'none';
        generateLevel(gameState.level);
        gameState.isRunning = true;
        update(); // Ensure loop is running
    }

    function updateUI() {
        document.getElementById('level-display').innerText = gameState.level;
        document.getElementById('hp-display').innerText = player.hp;
        document.getElementById('score-display').innerText = gameState.score;
    }

    /* --- INPUT HANDLERS --- */
    // Keyboard
    window.addEventListener('keydown', e => {
        if (e.key === 'ArrowLeft') keys.left = true;
        if (e.key === 'ArrowRight') keys.right = true;
        if (e.key === ' ' || e.key === 'ArrowUp') keys.jump = true;
        if (e.key === 'z' || e.key === 'Z') triggerAttack();
    });
    window.addEventListener('keyup', e => {
        if (e.key === 'ArrowLeft') keys.left = false;
        if (e.key === 'ArrowRight') keys.right = false;
        if (e.key === ' ' || e.key === 'ArrowUp') keys.jump = false;
    });

    // Touch
    const setupTouch = (id, key) => {
        const el = document.getElementById(id);
        el.addEventListener('touchstart', (e) => { e.preventDefault(); keys[key] = true; });
        el.addEventListener('touchend', (e) => { e.preventDefault(); keys[key] = false; });
    };
    setupTouch('btn-left', 'left');
    setupTouch('btn-right', 'right');
    setupTouch('btn-jump', 'jump');
    
    document.getElementById('btn-attack').addEventListener('touchstart', (e) => {
        e.preventDefault();
        triggerAttack();
    });

    function triggerAttack() {
        if (!player.attacking) {
            player.attacking = true;
            player.attackTimer = 15; // Duration of attack
        }
    }

    // Init
    draw(); // Start render loop
    showMsg("Hero Quest", "Level " + gameState.level);

</script>
</body>
</html>
